# 피보나치 수열 구현 비교


## 실행 명령어

### Gradle을 사용한 실행

```bash
# 모든 테스트 실행
./gradlew test

# 특정 테스트 메서드만 실행
./gradlew test --tests "MainTest.recursive"
./gradlew test --tests "MainTest.dpArray"
./gradlew test --tests "MainTest.dpMap"
./gradlew test --tests "MainTest.iterative"
./gradlew test --tests "MainTest.matrix"

# 테스트 결과를 상세히 출력
./gradlew test --info
```


## 구현 방식

### 1\. 재귀 호출 \(`FibonacciRecursive`\)

- **시간 복잡도**: `O(2^n)`
- **공간 복잡도**: `O(n)` \(콜 스택\)
- **특징**: 가장 직관적이지만 성능이 매우 낮음

---

### 2\. 동적 프로그래밍 - 배열 \(`FibonacciDPArray`\)

- **시간 복잡도**: `O(n)`
- **공간 복잡도**: `O(n)`
- **특징**: `HashMap`을 사용한 메모이제이션, 동적 크기 조정 가능

---

### 4\. 반복적 구현 \(`FibonacciIterative`\)

- **시간 복잡도**: `O(n)`
- **공간 복잡도**: `O(1)`
- **특징**: 가장 효율적인 공간 사용량

---

### 5\. 행렬 거듭제곱 \(`FibonacciMatrix`\)

- **시간 복잡도**: `O(log n)`
- **공간 복잡도**: `O(log n)`
- **특징**: 대용량 피보나치 수 계산에 최적화

---

## 성능 비교 결과

테스트 기기 (M1 MacBook Pro, 32GB RAM)

| 구현 방식      | 시간 복잡도 | 공간 복잡도 | n=50 실행시간  | n=50 기준   |
|:--------------|:-----------|:------------|:-----------|:----------|
| 재귀 호출     | O(2^n)     | O(n)        | 6min 52sec | ❌ (너무 느림) |
| DP 배열       | O(n)       | O(n)        | 5ms        | ✅         |
| DP 맵         | O(n)       | O(n)        | 3ms        | ✅         |
| 반복적        | O(n)       | O(1)        | 4ms        | ✅         |
| 행렬 거듭제곱 | O(log n)   | O(log n)    | 5ms        | ✅         |


## 결론

- **재귀 호출**은 성능이 매우 낮아 실용적이지 않음
  - 하지만 빠르게 만들 수 있어서, 피보나치의 숫자가 작을 때는 유용


- **행렬 거듭제곱**은 대용량 피보나치 수 계산에 최적화되어 있어 매우 빠름
    - 구현이 복잡하고, 수학적인 내용이 많아 이해하면서 짜기에는 어려움이 있음


- **동적 프로그래밍** 방식은 메모이제이션을 통해 성능을 크게 향상시킴
  - 코틀린은 Map을 사용할 때, 배열처럼 문법을 사용할 수 있어 편리함


- **반복적 구현**은 공간 효율성이 뛰어나며, 실제로 가장 빠름
  - 재귀 호출보다 훨씬 빠르고, 메모리 사용량도 적음


- 추천사용방법은 **동적 프로그래밍** 또는 **반복적 구현**  을 추천


- 대량의 피보나치를 계산한다는 전제가 있다면 **행렬 거듭제곱**을 추천합니다